// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {IncrementalMerkleTree} from "./IncrementalMerkleTree.sol";
import {ReentrancyGuard} from "./utils/ReentrancyGuard.sol";

/// @notice Interface for the ZK proof Verifier contract (e.g. generated by Barretenberg from the circuit).
interface IVerifier {
    function verifyProof(bytes calldata proof, bytes32[] calldata publicInputs) external view returns (bool);
}

contract Mixer is IncrementalMerkleTree, ReentrancyGuard {
    IVerifier public immutable i_verifier;

    mapping(bytes32 => bool) public s_commitments;
    /// @notice Tracks spent nullifier hashes to prevent double-spending (nullifier hash => used)
    mapping(bytes32 => bool) public s_nullifierHashes;

    uint256 public constant DENOMINATION = 0.001 ether;

    event Deposit(bytes32 indexed commitment, uint32 insertedIndex, uint256 timestamp);
    event Withdrawal(address indexed recipient, bytes32 indexed nullifierHash);

    error Mixer__CommitmentAlreadyAdded(bytes32 commitment);
    error Mixer__DepositAmountNotCorrect(uint256 amountSent, uint256 expectedAmount);
    error Mixer__InvalidProof();
    error Mixer__NullifierAlreadyUsed(bytes32 nullifierHash);
    error Mixer__UnknownRoot(bytes32 root);
    error Mixer__PaymentFailed(address recipient, uint256 amount);

    constructor(address _verifierAddress, uint32 _treeDepth) IncrementalMerkleTree(_treeDepth) {
        i_verifier = IVerifier(_verifierAddress);
    }

    /// @notice Deposit funds into the mixer; adds commitment to the Merkle tree and emits Deposit for off-chain sync.
    /// @param _commitment The Poseidon hash of the user's (off-chain generated) nullifier and secret.
    function deposit(bytes32 _commitment) external payable nonReentrant {
        if (s_commitments[_commitment]) {
            revert Mixer__CommitmentAlreadyAdded(_commitment);
        }
        if (msg.value != DENOMINATION) {
            revert Mixer__DepositAmountNotCorrect(msg.value, DENOMINATION);
        }

        uint32 insertedIndex = _insert(_commitment);
        s_commitments[_commitment] = true;

        emit Deposit(_commitment, insertedIndex, block.timestamp);
    }

    /// @notice Withdraw funds from the mixer in a private way using a ZK proof.
    /// @param _proof The ZK-SNARK proof (proves knowledge of commitment in tree and nullifier â†’ _nullifierHash).
    /// @param _root The Merkle root used in the proof; must be a known historical root (see isKnownRoot).
    /// @param _nullifierHash Poseidon hash of the user's private nullifier; prevents double-spend when marked used.
    /// @param _recipient Address to receive the withdrawn funds (public input to the circuit).
    function withdraw(
        bytes memory _proof,
        bytes32 _root,
        bytes32 _nullifierHash,
        address payable _recipient
    ) external nonReentrant {
        // 1. Root used in the proof must be in the stored history (allows slightly stale proofs)
        if (!isKnownRoot(_root)) {
            revert Mixer__UnknownRoot(_root);
        }

        // 2. Nullifier hash must not have been used (prevents double-spending the same deposit)
        if (s_nullifierHashes[_nullifierHash]) {
            revert Mixer__NullifierAlreadyUsed(_nullifierHash);
        }

        // 3. Construct public inputs in the order expected by the circuit (e.g. main.nr)
        bytes32[] memory publicInputs = new bytes32[](3);
        publicInputs[0] = _root;
        publicInputs[1] = _nullifierHash;
        publicInputs[2] = bytes32(uint256(uint160(address(_recipient))));

        // 4. Verify the ZK proof; revert if invalid
        if (!i_verifier.verifyProof(_proof, publicInputs)) {
            revert Mixer__InvalidProof();
        }

        // 5. Mark nullifier as used before external call (re-entrancy safety)
        s_nullifierHashes[_nullifierHash] = true;

        // 6. Send DENOMINATION ETH to the recipient (low-level call)
        (bool success, ) = _recipient.call{value: DENOMINATION}("");
        if (!success) {
            revert Mixer__PaymentFailed(_recipient, DENOMINATION);
        }

        emit Withdrawal(_recipient, _nullifierHash);
    }

    receive() external payable {
        revert("Mixer: use deposit()");
    }
}
